

# Семестр 2 #

## Задание 1. Реализация STL-контейнера ##

Deadline: 2013.03.10

Для каждого контейнера необходимо реализовать итератор и константный итератор.
Также должны быть представлены тесты, проверяющие работу всех методов классов + простейшая проверка на утечки памяти.

### Вариант 1. TVector`<`T`>` ###

Необходимо реализовать класс TVector`<`T`>` - аналог класса std::vector`<`T`>`.
Должны быть реализованы следующие методы:

  * size
  * empty
  * clear
  * swap
  * resize
  * capacity
  * reserve
  * begin
  * end
  * [ ]
  * back
  * front
  * push\_back
  * pop\_back
  * insert
  * erase
  * operator=

### Вариант 2. TList`<`T`>` ###

Необходимо реализовать класс TList`<`T`>` - аналог класса std::list`<`T`>`. Должны быть реализованы следующие методы:

  * empty
  * clear
  * swap
  * begin
  * end
  * back
  * front
  * push\_back
  * push\_front
  * pop\_back
  * pop\_front
  * insert
  * splice
  * erase
  * operator=

## Задание 2. Длинная арифметика ##

Deadline: 2013.03.17

Необходимо реализовать класс длинных беззнаковых чисел TBigUInt.

Длина числа - переменная (размер выделенной под число памяти растет при росте числа и уменьшается при уменьшении числа).

Для каждого алгоритма арифметических операций следует указать сложность.

Методы:
  * TBigUInt() - конструктор по умолчанию, создает число "0"
  * TBigUInt(const TBigInt&) - конструктор копирования
  * TBigUInt(unsigned int) - конструктор длинного числа из unsigned int
  * TBigUInt(unsigned long long) - конструктор длинного числа из unsigned long long
  * explicit TBigUInt(const char`*` str) - конструктор длинного числа из си-строки
  * explicit TBigUInt(const std::string& str) - конструктор длинного числа из std::string
  * operator=
  * operator+
  * operator-
  * operator`*` - должен быть реализован с использованием алгоритма умножения столбиком
  * operator/
  * operator++,-- (префиксная и постфиксная форма)
  * operator+=,-=,`*`=,/=
  * TBigUInt KaratsubaMultiply(const TBigUInt& a, const TBigUInt& b) - умножение длинных чисел, реализованное с помощью алгоритма Карацубы

Функции:
  * operator<< - печатает число в поток вывода
  * operator>> - читает длинное число из потока ввода

В main необходимо продемонстрировать работу чисел на нескольких примерах выполнения разных арифметических операций.

А также: построить графики времени умножения длинных чисел столбиком и с использованием алгоритма Карацубы от длины чисел. Тестировать на числах следующей длины (кол-во десятичных знаков): 100, 1'000, 10'000, 1'000'000, 10'000'000.

## Задание 3. Работа с матрицами ##

Deadline: 2013.03.24

Необходимо реализовать класс для работы с матрицами (2D):

```C++

template<typename T>
class TMatrix;
```

У класса должны быть реализованы следующие методы:
  * TMatrix()
  * TMatrix(const TMatrix &)
  * TMatrix(size\_t rowCount, size\_t colCount)
  * operator=
  * operator+,-
  * operator`*` - 2 версии: умножение на число и умножение на матрицу
  * operator+=, -=, `*`=
  * Resize(size\_t rowCount, size\_t colCount)
  * const T& At(size\_t row, size\_t col) const
  * T& At(size\_t row, size\_t col)
  * Transpose() - транспонирует матрицу
  * operator<<
  * operator>>
  * ShtrassenMultiply

Написать тесты, проверяющие всю функциональность класса + тесты на утечки памяти.

Умножение (operator`*`) необходимо реализовать по определению - за O(n^3).

Отдельной функцией/методом реализовать алгоритм умножения матриц Штрассена. Сравнить скорость его работы с умножением по определению на матрицах разного размера. Построить графики времени работы обоих алгоритмов от размера матриц (для тестов скорости можно брать квадратные матрицы).

## Задание 4. Геометрические примитивы ##

Deadline: 2013.04.01

Необходимо разработать классы для работы с геометрическими примитивами (на плоскости):

TPoint`<`T`>` - точка

TSegment`<`T`>` - отрезок

TPolygon`<`T`>` - многоугольник

TCircle`<`T`>` - круг

Все классы должны реализовывать интерфейс IShape:
```
template<typename T>
class IShape: {
public:
  virtual bool HasPoint(const TPoint<T>& p) const = 0; // Проверяет, что точка лежит внутри фигуры или на границе
  virtual bool Intersects(const TSegment <T>& s) const = 0; // Проверяет, что отрезок пересекает границу фигуры или касается ее
};
```

## Задание 5. Выпуклая оболочка ##

Deadline: 2013.04.15

Необходимо вычислить выпуклую оболочку множества точек на плоскости, используя алгоритм Грэхема.

**Input:**

Файл, каждая строка которого содержит целочисленные координаты одной из N точек (N=100), разделенные табом. Файл с входными данными лежит здесь: yuliy/task05\_convex\_hull/in1.txt

**Output:**

Файл с координатами точек выпуклой оболочки в том же формате.

## Задание 6. TDateTime ##

Deadline: 2013.05.06

Необходимо разработать классы для работы с датой и временем: TDateTime и TTimeSpan.

Класс TDateTime должен иметь следующие методы:
  * TDateTime () - создает объект, содержащий текущие дату и время
  * TDateTime (time\_t t) - где t - unix-timestamp
  * TDateTime (int year, int month, int day, int h, int m, int s)
  * TDateTime (int year, int month, int day)
  * TDateTime (string s)
  * operator<<, operator>> - ввод/вывод в поток
  * int Year () const
  * int Month () const
  * int Day () const
  * int Hour () const
  * int Minute () const
  * int Second () const
  * int `DayOfWeek ()` const
  * time\_t `GetUnixTimestamp()` const - возвращает unix timestamp
  * static TDateTime Now () - статический метод, возвращающий текущую дату-время
  * bool operator<
  * TDateTime operator+ (const TTimeSpan &delta) - возвращает дату-время, смещенную на delta
  * TDateTime operator- (const TTimeSpan &delta) - возвращает дату-время, смещенную на -delta
  * TTimeSpan operator- (const TDateTime &) - возвращает временной промежуток между двумя датами

Класс TTimeSpan предназначен для представления промежутков времени. Продумайте его интерфейс самостоятельно.

Прим.: прежде чем приступать к выполнению задания рекомендуется ознакомиться со следующими функциями стандартной библиотеки:
```
struct tm * gmtime (const time_t * timer);
struct tm * localtime (const time_t * timer);
time_t mktime (struct tm * timeptr);
size_t strftime (char* ptr, size_t maxsize, const char* format, const struct tm* timeptr );
```

Также рекомендуется прочитать следующие статьи:

http://ru.wikipedia.org/wiki/Unix_timestamp

http://ru.wikipedia.org/wiki/Gmt

http://ru.wikipedia.org/wiki/UTC


## Задание 7. BFS ##

Deadline: 2013.04.22

Необходимо реализовать алгоритм BFS для графа, описанного в файле yuliy/task07\_bfs/in.txt

В качестве источника выбрать первую вершину.

**Input:**

В первой строке файла содержатся 2 числа: N - кол-во вершин графа, M - кол-во ребер графа. Далее идут M строк, содержащих описание ребер. В каждой строке - по два числа: номер вершины-начала и номер вершины-конца ребра. Вершины нумеруются от 1 до N.

**Output:**

В i-ой строке результата вывести:
  * кратчайшее расстояние от источника до i-ой вершины
  * номер вершины-родителя i-ой вершины в дереве обхода графа в ширину

## Задание 8. DFS ##

Deadline: 2013.04.22

Необходимо реализовать алгоритм DFS для графа из задачи №7.

**Output:**

В i-ой строке результата вывести:
  * время открытия i-ой вершины при обходе графа в глубину
  * время закрытия i-ой вершины при обходе графа в глубину
  * номер вершины-родителя i-ой вершины в дереве обхода графа в глубину

## Задание 9. Topological Sort ##

Deadline: 2013.04.29

Для графа из задачи №7 получить топологически отсортированный граф.

**Output:**

Номера вершин графа в порядке топологической сортировки.

## Задание 10. SCCs ##

Deadline: 2013.04.29

Для графа из задачи №7 вычислить сильно связные компоненты.

**Output:**

Построчно перечислить номера вершин каждой сильно связной компоненты.

## Задание 11. Red-Black Tree ##

Deadline: 2013.05.13

Необходимо реализовать класс красно-черного дерева  TRBTree`<`T`>` по аналогии с std::set`<`T`>`.
Должны быть реализованы следующие методы:

  * TRBTree`<`T`>`()
  * TRBTree`<`T`>`( const TRBTree`<`T`>`& )
  * TRBTree`<`T`>` &operator=( const TRBTree`<`T`>`& )
  * swap
  * begin
  * end
  * empty
  * clear
  * erase
  * find
  * insert