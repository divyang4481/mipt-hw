<wiki:toc max_depth="5" />

=Семестр 2=

==Задание 1. Реализация STL-контейнера==

Deadline: 2013.03.10

Для каждого контейнера необходимо реализовать итератор и константный итератор.
Также должны быть представлены тесты, проверяющие работу всех методов классов + простейшая проверка на утечки памяти.

===Вариант 1. TVector`<`T`>`===

Необходимо реализовать класс TVector`<`T`>` - аналог класса std::vector`<`T`>`.
Должны быть реализованы следующие методы:

  * size
  * empty
  * clear
  * swap
  * resize
  * capacity
  * reserve
  * begin
  * end
  * [ ]
  * back
  * front
  * push_back
  * pop_back
  * insert
  * erase
  * operator=

===Вариант 2. TList`<`T`>`===

Необходимо реализовать класс TList`<`T`>` - аналог класса std::list`<`T`>`. Должны быть реализованы следующие методы:

  * empty
  * clear
  * swap
  * begin
  * end
  * back
  * front
  * push_back
  * push_front
  * pop_back
  * pop_front
  * insert
  * splice
  * erase
  * operator=

==Задание 2. Длинная арифметика==

Необходимо реализовать класс длинных беззнаковых чисел TBigUInt.

Длина числа - переменная (размер выделенной под число памяти растет при росте числа и уменьшается при уменьшении числа).

Для каждого алгоритма арифметических операций следует указать сложность.

Методы:
  * TBigUInt() - конструктор по умолчанию, создает число "0"
  * TBigUInt(const TBigInt&) - конструктор копирования
  * TBigUInt(unsigned int) - конструктор длинного числа из unsigned int
  * TBigUInt(unsigned long long) - конструктор длинного числа из unsigned long long
  * explicit TBigUInt(const char`*` str) - конструктор длинного числа из си-строки
  * explicit TBigUInt(const std::string& str) - конструктор длинного числа из std::string
  * operator=
  * operator+
  * operator-
  * operator`*` - должен быть реализован с использованием алгоритма умножения столбиком
  * operator/
  * operator++,-- (префиксная и постфиксная форма)
  * operator+=,-=,`*`=,/=
  * TBigUInt KaratsubaMultiply(const TBigUInt& a, const TBigUInt& b) - умножение длинных чисел, реализованное с помощью алгоритма Карацубы

Функции:
  * operator<< - печатает число в поток вывода
  * operator>> - читает длинное число из потока ввода

В main необходимо продемонстрировать работу чисел на нескольких примерах выполнения разных арифметических операций.

А также: построить графики времени умножения длинных чисел столбиком и с использованием алгоритма Карацубы от длины чисел. Тестировать на числах следующей длины (кол-во десятичных знаков): 100, 1'000, 10'000, 1'000'000, 10'000'000.

==Задание 3. Работа с матрицами==

Необходимо реализовать класс для работы с матрицами:

<code language="C++">
   template<typename T, int ROWS, int COLUMNS>
   class TMatrix;
</code>

У класса должно быть 3 шаблонных параметра: тип элементов, кол-во строк и кол-во столбцов, - чтобы все проверки размеров при работе с матрицами происходили автоматически компилятором.

Также необходимо реализовать следующие методы:
  * TMatrix()
  * TMatrix(const TMatrix &)
  * operator=
  * operator+,-
  * operator`*` - 2 версии: умножение на число и умножение на матрицу
  * operator+=, -=, `*`=
  * const T& operator[](int i, int j) const
  * T &operator[](int i, int j)
  * TMatrix Transposed() const - возвращает транспонированную матрицу
  * T Det() const - вычисляет определитель матрицы
  * operator<< - вывод в поток

Умножение необходимо реализовать по определению.

Отдельной функцией/методом реализовать алгоритм умножения матриц Штрассена. Сравнить скорость его работы с умножением по определению на матрицах разного размера.

==Задание 4. Геометрические примитивы==
Необходимо разработать классы для работы с геометрическими примитивами (на плоскости):

**TPoint`<`T`>`** - точка

TSegment`<`T`>` - отрезок

TPolygon`<`T`>` - многоугольник

TCircle`<`T`>` - круг

Предусмотреть у всех классов методы:

  *  HasPoint (const TPoint `<`T`>` `&`p) const; - проверяет, что точка принадлежит фигуре (включая границу)

  *  Intersects (const TSegment `<`T`>` `&`s) const; - проверяет, что отрезок пересекается с границей фигуры

==Задание 5. Выпуклая оболочка==

Необходимо вычислить выпуклую оболочку множества точек на плоскости.

*Input:*

Файл, каждая строка которого содержит целочисленные координаты одной из N точек (N=100), разделенные табом. Файл с входными данными лежит здесь: /mipt196/tasks/task05_convex_hull/in.txt

*Output:*

Файл с координатами точек выпуклой оболочки в том же формате.

==Задание 6. TDateTime==

Необходимо разработать классы для работы с датой и временем: TDateTime и TTimeSpan.

Класс TDateTime должен иметь следующие методы:
  * TDateTime () - создает объект, содержащий текущие дату и время
  * TDateTime (time_t t) - где t - unix-timestamp
  * TDateTime (int year, int month, int day, int h, int m, int s)
  * TDateTime (int year, int month, int day)
  * TDateTime (string s)
  * operator<<, operator>> - ввод/вывод в поток
  * int Year ()
  * int Month ()
  * int Day ()
  * int Hour ()
  * int Minute ()
  * int Second ()
  * int `DayOfWeek ()`
  * static TDateTime Now () - статический метод, возвращающий текущую дату-время
  * bool operator<
  * TDateTime operator+ (const TTimeSpan &delta) - возвращает дату-время, смещенную на delta
  * TDateTime operator- (const TTimeSpan &delta) - возвращает дату-время, смещенную на -delta
  * TTimeSpan operator- (const TDateTime &) - возвращает временной промежуток между двумя датами

Класс TTimeSpan предназначен для представления промежутков времени. Продумайте его интерфейс самостоятельно.

== Задание 7. BFS ==

Необходимо реализовать алгоритм BFS для графа, описанного в файле /mipt196/tasks/task07_bfs/in.txt

В качестве источника выбрать первую вершину.

*Input:*

В первой строке файла содержатся 2 числа: N - кол-во вершин графа, M - кол-во ребер графа. Далее идут M строк, содержащих описание ребер. В каждой строке - по два числа: номер вершины-начала и номер вершины-конца ребра. Вершины нумеруются от 1 до N.

*Output:*

В i-ой строке результата вывести:
  * кратчайшее расстояние от источника до i-ой вершины
  * номер вершины-родителя i-ой вершины в дереве обхода графа в ширину

== Задание 8. DFS ==

Необходимо реализовать алгоритм DFS для графа из задачи №7.

*Output:*

В i-ой строке результата вывести:
  * время открытия i-ой вершины при обходе графа в глубину
  * время закрытия i-ой вершины при обходе графа в глубину
  * номер вершины-родителя i-ой вершины в дереве обхода графа в глубину

== Задание 9. Topological Sort ==

Для графа из задачи №7 получить топологически отсортированный граф.

*Output:*

Номера вершин графа в порядке топологической сортировки.

== Задание 10. SCCs ==

Для графа из задачи №7 вычислить сильно связные компоненты.

*Output:*

Построчно перечислить номера вершин каждой сильно связной компоненты.

== Задание 11. Red-Black Tree ==

Необходимо реализовать класс красно-черного дерева  TRBTree`<`T`>` по аналогии с std::set`<`T`>`.
Должны быть реализованы следующие методы:

  * TRBTree`<`T`>`()
  * TRBTree`<`T`>`( const TRBTree`<`T`>`& )
  * TRBTree`<`T`>` &operator=( const TRBTree`<`T`>`& )
  * swap
  * begin
  * end
  * empty
  * clear
  * erase
  * find
  * insert