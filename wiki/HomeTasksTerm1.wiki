<wiki:toc max_depth="5" />

=Семестр 1=

== Задание 1. Bubble Sort ==

Deadline: 2012.10.08

Необходимо написать программу сортировки массива чисел с использованием алгоритма BubbleSort.

Прим.:
  1. Алгоритм сортировки должен быть реализован в отдельной функции BubbleSort.
  2. Программа должна резервировать объем памяти, минимально необходимый для сортировки указанного кол-ва чисел.

*Input:*

Чтение из stdin.
В первой строке - кол-во чисел N (1 <= N <= 1e9).
Во второй строке - N чисел, разделенных пробелом (значения чисел лежат в  диапазоне [-1e9; +1e9]).

*Output:*

Вывод в stdout.
Строка чисел, отсортированных по возрастанию (разделитель - пробел).

== Задание 2. Merge Sort ==

Deadline: 2012.10.08

Необходимо написать программу сортировки массива чисел с использованием алгоритма MergeSort.

Примечания и формат ввода/вывода см. в Задании 1.

== Задание 3. Insert Sort ==

Deadline: 2012.10.08

Необходимо написать программу сортировки массива чисел с использованием алгоритма InsertSort.

Примечания и формат ввода/вывода см. в Задании 1.

== Задание 4. Quick Sort ==

Deadline: 2012.10.08

Необходимо написать программу сортировки массива чисел с использованием алгоритма QuickSort.

Примечания и формат ввода/вывода см. в Задании 1.

== Задание 5. Radix Sort ==

Deadline: 2012.10.15

Необходимо написать программу сортировки массива чисел с использованием алгоритма RadixSort.

Примечания и формат ввода/вывода см. в Задании 1.


== Задание 6. Heap Sort ==

Deadline: 2012.10.22

Необходимо написать программу сортировки массива чисел с использованием алгоритма HeapSort.

Примечания и формат ввода/вывода см. в Задании 1.

== Задание 7. Сравнение алгоритмов сортировки ==

Deadline: 2012.10.22

Необходимо написать программу, оценивающую скорость работы каждого алгоритма сортировки из заданий 2-6, а также встроенной функции qsort.

*Input:*
Программа должна принимать на stdin одно число: размер массива.

*Output:*
В stdout для каждого алгоритма - строчка:
<НазваниеАлгоритма> <время работы алгоритма в мс> <корректность работы (true/false)>

Для оценки времени работы алгоритма программа должна:

  1. Генерировать массив чисел типа int в диапазоне [-1e9; +1e9].

  2. Вызывать соответствующий алгоритм, измеряя время его работы.

  3. Проверять корректность сортировки (числа в результирующем массиве должны лежать по неубыванию). Для проверки корректности должна быть отдельная функция, принимающая на вход массив.

После реализации программы, необходимо запустить ее для разного объема данных: 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8. По полученным данных построить график зависимости времени работы от размера задачи (в чем удобно: Excel, Python/matplotlib, ...).
Скрин графика приложить к Issue.

Прим.: Для оценки времени используйте функцию clock(), а не GetTickCount(). Последняя выдает текущее время. А clock честно считает процессорные такты Вашего процесса. К тому же, GetTickCount не входит в стандарт С++ (Visual Studio specific). Подробнее об этой функции можно почитать здесь: http://www.cplusplus.com/reference/clibrary/ctime/clock/

== Задание 8. Расщепление строки ==

Deadline: 2012.10.29

Напишите программу, расщепляющую строку по указанному разделителю.

*Input:*

На stdin приходят две строки (не содержащие пробелов, символов табуляции и переноса строк). Первая строка - которую нужно расщепить. Вторая - разделитель. Размер строк - не более 10000 символов.

*Output:*

В stdout - результат в виде списка строк: каждая строка на отдельной строчке в консоли.

*Доп. требования:*

В программе должна быть реализована функция расщепления строки со следующей сигнатурой:
{{{
char** split(const char *str, const char *delim);
}}}

А также функция удаления результата работы первой функции:
{{{
void delete_string_array(char **str);
}}}

== Задание 9. Простое число ==

Deadline: 2012.10.29

Напишите программу, проверяющую, является ли введенное число n простым.

*Input:*

На stdin подается целое число n (1 <= n <= 1e9).

*Output:*

На stdout строка YES, если число простое. NO - в противном случае.

== Задание 10. Биномиальные коэффициенты ==

Deadline: 2012.10.29

Напишите программу, вычисляющую коэффициенты в разложении:
{{{
(1+x)^n = C(n,0) * x^0 + C(n,1) * x^1 + ... + C(n,n) * x^n
}}}

Оцените сложность предложенного Вами алгоритма по времени и по памяти.

*Input:*

На stdin поступает одно число n -порядок полинома.

*Output:*

В stdout построчно должны быть выведены коэффициенты разложения.

== Задание 11. Частичная сумма ряда ==

Deadline: 2012.10.29

Посчитайте сумму первых n членов ряда 1/(n^2) в возрастающем и в убывающем порядке (для разных типов с плавающей точкой: float, double, long double).

*Input:*

На stdin поступает одно число n - кол-во членов ряда.

*Output:*

На отдельных строчках вывести:

Сумма первых n членов ряда, посчитанная по возрастанию (для типа float).

Сумма первых n членов ряда. посчитанная по убыванию (для типа float).

Сумма первых n членов ряда, посчитанная по возрастанию (для типа double).

Сумма первых n членов ряда. посчитанная по убыванию (для типа double).

Сумма первых n членов ряда, посчитанная по возрастанию (для типа long double).

Сумма первых n членов ряда. посчитанная по убыванию (для типа long double).

== Задание 12. Компенсационное суммирование ==

Deadline: 2012.11.05

Необходимо написать программу, вычисляющую сумму массива чисел типа float с использованием алгоритмов компенсационного суммирования: алгоритм Кахана и алгоритм, основанный на очереди с приоритетами. Сравните полученные результаты. Оцените сложность обоих алгоритмов по времени и по памяти.

*Input:*

На stdin подается целое число n (1 <= n <= 1e8). Далее - n чисел с плавающей точкой (не более 7 значащих цифр).

*Output:*

На stdout вывести:

Результат суммирования чисел с использованием алгоритма Кахана (+ время работы, измеренное с помощью функции clock).

Результат суммирования чисел с использованием алгоритма, использующего очередь с приоритетами (+ время работы).

*Прим.:*

Алгоритм Кахана в Wikipedia: http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D1%8D%D1%85%D1%8D%D0%BD%D0%B0

== Задание 13. Список ==

Deadline: 2012.11.12

Необходимо разработать класс для работы с двусвязным списком TList (элементы списка - объекты типа int). В классе должны быть реализованы следующие public методы:

{{{
TList(); // конструктор по умолчанию - создает пустой список

TList(const TList& other); // конструктор копирования

TList& operator=(const TList &other); // оператор копирующего присваивания

~TList(); // деструктор (удаляет все элементы, которыми владеет список)

bool IsEmpty() const; // возвращает true, если список пустой

int First() const; // возвращает ссылку на первый элемент списка 
// (если список пустой - undefined behaviour)

int Last() const; // возвращает ссылку на последний элемент списка
//(если список пустой - undefined behaviour)

const TNode* FirstNode() const;
TNode* FirstNode(); // возвращает указатель на начальную ноду списка

const TNode* LastNode() const;
TNode* LastNode(); // возвращает указатель на конечную ноду списка

void PushBack(int val); // вставляет в конец списка элемент со значением val

void PushBack(TNode* node); // вставляет в конец списка узел node.
// Узел при этом переходит во владение объекта-списка

void PushFront(int val); // вставляет в начало спика элемент со значением val

void PushFront(TNode* node); // вставляет в начало списка узел node.
// Узел при этом переходит во владение объекта-списка

void Insert(TNode* where, int val); // вставляет перед узлом where узел со значением val

void Insert(TNode* where, TNode* node); // вставляет перед узлом where узел node.
// Узел при этом переходит во владение объекта-списка

void Insert(TNode* where, TList &other); // вставляет перед узлом where все элементы списка other (за O(1)).
// При этом список other становится пустым и все его элементы переходят во владение
// текущего объекта-списка (чей метод вызван)

int PopLast(); // извлекает из списка последний элемента, освобождает память,
// выделенную под него, и возвращает значение элемента

int PopFirst(); // извлекает из списка первый элемент, освобождает память,
// выделенную под него, и возвращает значение элемента

TNode* ExtractLast(); // извлекает из списка последний узел и возвращает указатель на него;
// за владение узла отвечает вызвавший метод клиентский код

TNode* ExtractFirst(); // извлекает из списка первый узел и возвращает указатель на него;
// за владение узла отвечает вызвавший метод клиентский код

void Delete(TNode* node); // удаляет из списка узел node

void Delete(TNode* from, TNode *to); // удаляет из списка все элемента от from до to

TNode* Extract(TNode* node); // извлекает из списка узел node и возвращает указатель на него;
// за владение узла отвечает вызвавший метод клиентский код

TList Extract(TNode* from, TNode* to); // извлекает из списка интервал элментов от from до to.
// возвращает объект TList, содержащий этот интервал
}}}

В программе должны быть реализованы тесты, демонстрирующие и проверяющую работу всех методов класса (отдельными функциями). Функции-тесты должны вызываться из main.

== Задание 14. Порядковые статистики == 

Deadline: 2012.11.12

Необходимо написать программу, определяющую k-ую порядковую статистику массива чисел.

*Input:*

Ввод через stdin. В первой строке ввода - кол-во элементов массива n (1 <= n <= 1e9). Во второй строке - номер статистики k, которую нужно определить (1 <= k <= n). Далее - n строк, содержащих целые числа a_i (-1e9 <= a_i <= 1e9).

*Output:*

Значение k-ой порядковой статистики введенного массива данных.

*Прим.:* для определения k-ой порядковой статистики должен быть реализован алгоритм, основанный на QuickSort. В нем должны быть приняты меры борьбы с деградацией в худшем случае. Т.е. программа должна работать за O(n) на любых введенных данных. Меры борьбы с деградацией - на Ваш выбор.

== Задание 15. Скобки 1 ==

Deadline: 2012.11.19

*Input:*

В stdin: строка, состоящая из N (1 <= N <= 10000) символов: '(', ')'. 

*Output:*

В stdout: строка "YES", если введенная скобочная структура является правильной, в противном случае строка "NO".

== Задание 16. Скобки 2 ==

Deadline: 2012.11.19

*Input:*

 В stdin: целое число n (1 <= n <= 10000).

*Output:*

В stdout: кол-во правильных скобочных последовательностей длины 2n.

*Прим:*

Есть два возможных решения этой задачи:

1. Оно эквивалентно кол-ву возможных путей в следующей сетке: http://pustovoytov.com/redpms/attachments/87/ris1.PNG

2. Числа Каталана. Подробнее можно почитать здесь: http://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%B0%D0%BD%D0%B0

== Задание XX. Shell Sort ==

Deadline: 2012.11.XX

Необходимо написать программу сортировки массива чисел с использованием алгоритма ShellSort.

Примечания и формат ввода/вывода см. в Задании 1.