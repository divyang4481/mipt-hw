<wiki:toc max_depth="5" />

=Семестр 1=

== Задание 1. Bubble Sort ==

Deadline: 2012.10.08

Необходимо написать программу сортировки массива чисел с использованием алгоритма BubbleSort.

Прим.:
  1. Алгоритм сортировки должен быть реализован в отдельной функции BubbleSort.
  2. Программа должна резервировать объем памяти, минимально необходимый для сортировки указанного кол-ва чисел.

*Input:*

Чтение из stdin.
В первой строке - кол-во чисел N (1 <= N <= 1e9).
Во второй строке - N чисел, разделенных пробелом (значения чисел лежат в  диапазоне [-1e9; +1e9]).

*Output:*

Вывод в stdout.
Строка чисел, отсортированных по возрастанию (разделитель - пробел).

== Задание 2. Merge Sort ==

Deadline: 2012.10.08

Необходимо написать программу сортировки массива чисел с использованием алгоритма MergeSort.

Примечания и формат ввода/вывода см. в Задании 1.

== Задание 3. Insert Sort ==

Deadline: 2012.10.08

Необходимо написать программу сортировки массива чисел с использованием алгоритма InsertSort.

Примечания и формат ввода/вывода см. в Задании 1.

== Задание 4. Quick Sort ==

Deadline: 2012.10.08

Необходимо написать программу сортировки массива чисел с использованием алгоритма QuickSort.

Примечания и формат ввода/вывода см. в Задании 1.

== Задание 5. Radix Sort ==

Deadline: 2012.10.15

Необходимо написать программу сортировки массива чисел с использованием алгоритма RadixSort.

Примечания и формат ввода/вывода см. в Задании 1.


== Задание 6. Heap Sort ==

Deadline: 2012.10.22

Необходимо написать программу сортировки массива чисел с использованием алгоритма HeapSort.

Примечания и формат ввода/вывода см. в Задании 1.

== Задание 7. Сравнение алгоритмов сортировки ==

Deadline: 2012.10.22

Необходимо написать программу, оценивающую скорость работы каждого алгоритма сортировки из заданий 2-6, а также встроенной функции qsort.

*Input:*
Программа должна принимать на stdin одно число: размер массива.

*Output:*
В stdout для каждого алгоритма - строчка:
<НазваниеАлгоритма> <время работы алгоритма в мс> <корректность работы (true/false)>

Для оценки времени работы алгоритма программа должна:

  1. Генерировать массив чисел типа int в диапазоне [-1e9; +1e9].

  2. Вызывать соответствующий алгоритм, измеряя время его работы.

  3. Проверять корректность сортировки (числа в результирующем массиве должны лежать по неубыванию). Для проверки корректности должна быть отдельная функция, принимающая на вход массив.

После реализации программы, необходимо запустить ее для разного объема данных: 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8. По полученным данных построить график зависимости времени работы от размера задачи (в чем удобно: Excel, Python/matplotlib, ...).
Скрин графика приложить к Issue.

Прим.: Для оценки времени используйте функцию clock(), а не GetTickCount(). Последняя выдает текущее время. А clock честно считает процессорные такты Вашего процесса. К тому же, GetTickCount не входит в стандарт С++ (Visual Studio specific). Подробнее об этой функции можно почитать здесь: http://www.cplusplus.com/reference/clibrary/ctime/clock/

== Задание 8. Расщепление строки ==

Deadline: 2012.10.29

Напишите программу, расщепляющую строку по указанному разделителю.

*Input:*

На stdin приходят две строки (не содержащие пробелов, символов табуляции и переноса строк). Первая строка - которую нужно расщепить. Вторая - разделитель. Размер строк - не более 10000 символов.

*Output:*

В stdout - результат в виде списка строк: каждая строка на отдельной строчке в консоли.

*Доп. требования:*

В программе должна быть реализована функция расщепления строки со следующей сигнатурой:
{{{
char** split(const char *str, const char *delim);
}}}

А также функция удаления результата работы первой функции:
{{{
void delete_string_array(char **str);
}}}

== Задание 9. Простое число ==

Deadline: 2012.10.29

Напишите программу, проверяющую, является ли введенное число n простым.

*Input:*

На stdin подается целое число n (1 <= n <= 1e9).

*Output:*

На stdout строка YES, если число простое. NO - в противном случае.

== Задание 10. Биномиальные коэффициенты ==

Deadline: 2012.10.29

Напишите программу, вычисляющую коэффициенты в разложении:
{{{
(1+x)^n = C(n,0) * x^0 + C(n,1) * x^1 + ... + C(n,n) * x^n
}}}

Оцените сложность предложенного Вами алгоритма по времени и по памяти.

*Input:*

На stdin поступает одно число n -порядок полинома.

*Output:*

В stdout построчно должны быть выведены коэффициенты разложения.

== Задание 11. Частичная сумма ряда ==

Deadline: 2012.10.29

Посчитайте сумму первых n членов ряда 1/(n^2) в возрастающем и в убывающем порядке (для разных типов с плавающей точкой: float, double, long double).

*Input:*

На stdin поступает одно число n - кол-во членов ряда.

*Output:*

На отдельных строчках вывести:

Сумма первых n членов ряда, посчитанная по возрастанию (для типа float).

Сумма первых n членов ряда. посчитанная по убыванию (для типа float).

Сумма первых n членов ряда, посчитанная по возрастанию (для типа double).

Сумма первых n членов ряда. посчитанная по убыванию (для типа double).

Сумма первых n членов ряда, посчитанная по возрастанию (для типа long double).

Сумма первых n членов ряда. посчитанная по убыванию (для типа long double).

== Задание 12. Компенсационное суммирование ==

Deadline: 2012.11.05

Необходимо написать программу, вычисляющую сумму массива чисел типа float с использованием алгоритмов компенсационного суммирования: алгоритм Кахана и алгоритм, основанный на очереди с приоритетами. Сравните полученные результаты. Оцените сложность обоих алгоритмов по времени и по памяти.

*Input:*

На stdin подается целое число n (1 <= n <= 1e8). Далее - n чисел с плавающей точкой (не более 7 значащих цифр).

*Output:*

На stdout вывести:

Результат суммирования чисел с использованием алгоритма Кахана (+ время работы, измеренное с помощью функции clock).

Результат суммирования чисел с использованием алгоритма, использующего очередь с приоритетами (+ время работы).

*Прим.:*

Алгоритм Кахана в Wikipedia: http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D1%8D%D1%85%D1%8D%D0%BD%D0%B0

== Задание 13. Список ==

Deadline: 2012.11.12

Необходимо разработать класс для работы с двусвязным списком TList (элементы списка - объекты типа int). В классе должны быть реализованы следующие public методы:

{{{
TList(); // конструктор по умолчанию - создает пустой список

TList(const TList& other); // конструктор копирования

TList& operator=(const TList &other); // оператор копирующего присваивания

~TList(); // деструктор (удаляет все элементы, которыми владеет список)

bool IsEmpty() const; // возвращает true, если список пустой

int First() const; // возвращает ссылку на первый элемент списка 
// (если список пустой - undefined behaviour)

int Last() const; // возвращает ссылку на последний элемент списка
//(если список пустой - undefined behaviour)

const TNode* FirstNode() const;
TNode* FirstNode(); // возвращает указатель на начальную ноду списка

const TNode* LastNode() const;
TNode* LastNode(); // возвращает указатель на конечную ноду списка

void PushBack(int val); // вставляет в конец списка элемент со значением val

void PushBack(TNode* node); // вставляет в конец списка узел node.
// Узел при этом переходит во владение объекта-списка

void PushFront(int val); // вставляет в начало спика элемент со значением val

void PushFront(TNode* node); // вставляет в начало списка узел node.
// Узел при этом переходит во владение объекта-списка

void Insert(TNode* where, int val); // вставляет перед узлом where узел со значением val

void Insert(TNode* where, TNode* node); // вставляет перед узлом where узел node.
// Узел при этом переходит во владение объекта-списка

void Insert(TNode* where, TList &other); // вставляет перед узлом where все элементы списка other (за O(1)).
// При этом список other становится пустым и все его элементы переходят во владение
// текущего объекта-списка (чей метод вызван)

int PopLast(); // извлекает из списка последний элемента, освобождает память,
// выделенную под него, и возвращает значение элемента

int PopFirst(); // извлекает из списка первый элемент, освобождает память,
// выделенную под него, и возвращает значение элемента

TNode* ExtractLast(); // извлекает из списка последний узел и возвращает указатель на него;
// за владение узла отвечает вызвавший метод клиентский код

TNode* ExtractFirst(); // извлекает из списка первый узел и возвращает указатель на него;
// за владение узла отвечает вызвавший метод клиентский код

void Delete(TNode* node); // удаляет из списка узел node

void Delete(TNode* from, TNode *to); // удаляет из списка все элемента от from до to

TNode* Extract(TNode* node); // извлекает из списка узел node и возвращает указатель на него;
// за владение узла отвечает вызвавший метод клиентский код

TList Extract(TNode* from, TNode* to); // извлекает из списка интервал элментов от from до to.
// возвращает объект TList, содержащий этот интервал
}}}

В программе должны быть реализованы тесты, демонстрирующие и проверяющую работу всех методов класса (отдельными функциями). Функции-тесты должны вызываться из main.

== Задание 14. Порядковые статистики == 

Deadline: 2012.11.12

Необходимо написать программу, определяющую k-ую порядковую статистику массива чисел.

*Input:*

Ввод через stdin. В первой строке ввода - кол-во элементов массива n (1 <= n <= 1e9). Во второй строке - номер статистики k, которую нужно определить (1 <= k <= n). Далее - n строк, содержащих целые числа a_i (-1e9 <= a_i <= 1e9).

*Output:*

Значение k-ой порядковой статистики введенного массива данных.

*Прим.:* для определения k-ой порядковой статистики должен быть реализован алгоритм, основанный на QuickSort. В нем должны быть приняты меры борьбы с деградацией в худшем случае. Т.е. программа должна работать за O(n) на любых введенных данных. Меры борьбы с деградацией - на Ваш выбор.

== Задание 15. Скобки 1 ==

Deadline: 2012.11.19

*Input:*

В stdin: строка, состоящая из N (1 <= N <= 10000) символов: '(', ')'. 

*Output:*

В stdout: строка "YES", если введенная скобочная структура является правильной, в противном случае строка "NO".

== Задание 16. Скобки 2 ==

Deadline: 2012.11.19

*Input:*

 В stdin: целое число n (1 <= n <= 10000).

*Output:*

В stdout: кол-во правильных скобочных последовательностей длины 2n.

*Прим:*

Есть два возможных решения этой задачи:

1. Оно эквивалентно кол-ву возможных путей в следующей сетке:

http://pustovoytov.com/redpms/attachments/87/ris1.PNG

2. Числа Каталана. Подробнее можно почитать здесь:

http://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%9A%D0%B0%D1%82%D0%B0%D0%BB%D0%B0%D0%BD%D0%B0

== Задание 17. Представимость чисел ==

Deadline: 2012.11.19

Какие из указанных чисел представимы типом double: 0, -1345, 1, 1.5, 2/3, 3/2, 1.66, 1.75, 1/70, 1/125, 1/256,1010 , 1022, 111111111?

== Задание 18. Представление типа double ==

Deadline: 2012.11.19

Напишите программу для изучения внутреннего представления типа double. Для каждой введенной десятичной записи числа с плавающей точкой программа должна выводить sizeof(double) x 8 бит, соответствующих представлению данного числа типом double. Для решения этой задачи реализуйте функцию

{{{
void PrintMem(const void *ptr, int size);
}}}

которая выводит двоичное представление size байт, расположенных по адресу mem.

Приведите примеры чисел (ноль, единица, маленькие положительные и отрицательные, большие положительные и отрицательные) и их бинарное представление. Объясните (письменно) устройство чисел типа double.

== Задание 19. База данных студентов =
Deadline: 2012.12.10

Напишите программу для работы с базой данных студентов.

=== Запуск программы ===

Если кол-во аргументов командной строки не один, программа должна выдавать в консоль сообщение об ошибке, справку, как правильно пользоваться программой и завершить выполнение.

Если есть ровно один аргумент и он равен "--help", программа должна вывести в консоль справку и завершить выполнение.

Если аргумент один и он не равен "--help", то он должен трактоваться как путь к файлу с базой студентов. Если файл по такому пути не существует, он должен быть создан автоматически. Если файл не удается открыть, программа должна сообщить о соответствующей ошибке и завершиться.

Примеры:

{{{
students.exe
  Failed starting students.exe!
  Error description: not enough command-line arguments!
  Usage:
     students.exe <db_path.exe>

students.exe 1 2 3
  Failed starting students.exe!
  Error description: too many command-line arguments!
  Usage:
     students.exe <db_path.exe>

students.exe --help
  Usage:
     students.exe <db_path.exe>

students.exe C:\students.txt
  Failed starting students.exe!
  Error description: could not open file: "C:\students.txt"!
  Usage:
     students.exe <db_path.exe>
}}}

=== Формат базы данных ===

База студентов должна храниться в виде одного текстового файла. Каждая строка файла - запись в базе. В строке - поля через символ ';'. Если в самих полях присутствует символ ';', он должен экранировться обратным слешем: '\;' (по аналогии с си-строками). Соответственно при чтении из базы, нужно отличать экранированный символ и реальный разделитель.

В программе каждая запись о студенте должны быть представлена структурой со следующими полями:

{{{
const int MAX_NAME_SIZE = 30;
const int MAX_LASTNAME_SIZE = 50;
const int MAX_BIO_SIZE = 1024;

struct TStudent {
   char Name[MAX_NAME_SIZE]; // Имя 
   char LastName[MAX_LASTNAME_SIZE]; // Фамилия
   int ID; // Номер студ билета
   float AverageMark; // Средний балл
   char Bio[MAX_BIO_SIZE]; // Биография

   // контструкторы, деструктор, оператор= и т.п. - добавить по смыслу
};
}}}

=== Интерфейc взаимодействия с пользователем ===

В случае успешного запуска программа должна загрузить в память содержимое базы данных, сообщить о кол-ве загруженных объектов и вывести подсказку к возможным дейcтвиям пользователя:

{{{
students.exe C:\students.txt
   Database successfully loaded!
   Possible commands:
     search
     add
     del
     printall
     quit
   Enter command:

}}}

==== search ====
Если пользователь ввел команду search, программа должна предложить поиск по следующим возможным вариантам: Фамилия, Фамилия+Имя, НомерСтудБилета:
{{{
search
   Enter:
     1 - to search by LastName
     2 - to search by LastName+Name
     3 - to search by ID
1
   Enter LastName:
Ivanov
   Students found with LastName="Ivanov": 2
   -------------------------------------
   Name: Peter
   LastName: Ivanov
   ID: 1017
   AverageMark: 4.8
   Bio: Good boy

   -------------------------------------
   Name: Damien
   LastName: Ivanov
   ID: 666
   AverageMark: 1.5
   Bio: Pure Evil!
}}}

==== add ====
После ввода этой команды, программа должна предложить ввести параметры нового студента. Если студент с таким ID уже есть - вывести сообщение об ошибке. В потивном случае сообщить, что студент успешно добавлен.

==== del ====
После ввода этой команды, программа должна предложить ввести ID студента. Если такой студент есть в базе, удалить его. В потивном случае - сообщить об ошибке.

==== printall ====
Выводить информацию обо всех студентах в базе (в алфавитном порядке по LastName+Name).

==== quit ====
Сохраняет все изменения в базу и завершает работу программы.

== Задание XXXXXX. Shell Sort ==

Deadline: 2012.12.XX

Необходимо написать программу сортировки массива чисел с использованием алгоритма ShellSort.

Примечания и формат ввода/вывода см. в Задании 1.